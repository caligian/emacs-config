(defun container? (x)
  (or (ht-p x)
      (eieio-object-p x)
      (alistp x)
      (listp x)))

(defalias 'containerp 'container?)

(defun %get (X &rest KS)
  (cl-labels ((list-get (x k)
				(when-let* ((ok? (numberp k))
							(len (length x))
							(k (if (< k 0) (+ len k) k))
							(k (when (< k len) k)))
				  (nth k x)))
			  (alist-get (x k)
				(when-let* ((v (assoc k x))
							(v (cdr v)))
				  (if (and (list? v) (= 1 (length v)))
					  (nth 0 v)
					v)))
			  (hash-table-get (x k)
				(get% x k))
			  (object-get (x k)
				(and (slot-exists-p x k)
					 (slot-boundp x k)
					 (slot-value x k)))
			  (get (x k)
				(cond
				 ((alistp x)
				  (alist-get x k))
				 ((listp x)
				  (list-get x k))
				 ((ht-p x)
				  (ht-get x k))
				 ((eieio-object-p x)
				  (object-get x k))))
			  (rget (x ks)
				(let* ((k (car ks))
					   (next (cdr ks))
					   (v (get x k)))
				  (if (not next)
					  v
					(when (container? v)
					  (rget v next))))))
	(rget X KS)))

(defun %rm (X &rest ks)
  (cl-labels ((list-rm (x k)
				(when-let* ((ok? (numberp k))
							(len (length x))
							(k (if (< k 0) (+ len k) k))
							(k (when (< k len) k))
							(v (nth k x)))
				  (if (equal k 0)
					  (progn
						(setcar x (car (cdr x)))
						(setcdr x (cdr (cdr x)))
						v)
					(progn
					  (setcdr (nthcdr (1- k) x) (nthcdr (1+ k) x))
					  v))))
			  (hash-table-rm (x k)
				(let* ((v (ht-get x k)))
				  (ht-remove x k)
				  v))
			  (alist-rm (x k)
				(when-let* ((v (assoc k x)))
				  (assq-delete-all k x)
				  v))
			  (object-rm (x k)
				(let* ((v (and (slot-exists-p x k)
							   (slot-boundp x k)
							   (slot-value x k))))
				  (slot-unbound x k)
				  v))
			  (RM (x k)
				(cond
				 ((alistp x)
				  (alist-rm x k))
				 ((listp x)
				  (list-rm x k))
				 ((ht-p x)
				  (hash-table-rm x k))
				 ((eieio-object-p x)
				  (object-rm x k)))))
	(if (singleton? ks)
		(RM X (last@ ks))
	  (let* ((found (apply #'%get X ks))
			 (level (apply #'%get X (butlast ks))))
		(RM level (last@ ks))
		found))))

(defun %set (X &rest ks-and-value)
  (cl-labels ((list-set (x k value)
				(when-let* ((ok? (numberp k))
							(len (length x))
							(k (if (< k 1) (+ len x) k))
							(k (when (k < len) k)))
				  (setf (nth k x) value)
				  x))
			  (hash-table-set (x k value)
				(ht-set x k value)
				x)
			  (alist-set (x k value)
				(when-let* ((v (assoc k x)))
				  (setf (cdr v) value)
				  v))
			  (object-set (x k value)
				(when (slot-exists-p x k)
				  (setf (slot-value x k) value)
				  x))
			  (SET (x k value)
				(cond
				 ((alistp x)
				  (alist-set x k value))
				 ((listp x)
				  (list-set x k value))
				 ((ht-p x)
				  (hash-table-set x k value))
				 ((eieio-object-p x)
				  (object-set x k value))))
			  (RSET (x ks value)
				(if (singleton? ks)
					(SET x (car ks) value)
				  (when-let* ((found (apply #'%get x (butlast ks))))
					(when (container? found)
					  (SET found (last@ ks) value))))))
    (RSET X (butlast ks-and-value) (last@ ks-and-value))))

(defun %update (x &rest ks-and-fn)
  (when-let* ((fn (last@ ks-and-fn))
			  (ks (butlast ks-and-fn))
			  (v (apply '%get x ks))
			  (v (funcall fn v)))
	(apply '%set x (append@ ks v))))

(defun %select (x &rest ks)
  (cl-loop for k in ks
		   collect (apply '%get x (->list k))))

(defun %rmq (x &rest ks)
  (cl-loop for k in ks
		   collect (apply '%rm x (->list k))))

(defun %setq (x &rest form)
  (cl-loop for i from 0 below (length form)
		   when (= 0 (% i 2))
		   do (let* ((k (->list (nth i form)))
					 (v (nth (+ i 1) form)))
				(apply #'%set x (append@ k v))))
  x)

(defun %compare (X SPEC)
  (cl-labels
	  ((MATCH-TABLE (x spec)
		 (cond
		  ((functionp spec)
		   (and (funcall spec x) x))
		  ((and (listp x) (listp spec))
		   (let* ((success? t)
				  (i 0)
				  (x-len (length x))
				  (spec-len (length spec))
				  (limit (min x-len spec-len)))
			 (while (and success? (< i limit))
			   (let* ((x-value (nth i x))
					  (spec-value (nth i spec)))
				 (cond
				  ((and (container? x-value)
						(container? spec-value))
				   (setq success? (MATCH-TABLE x-value spec-value)))
				  ((and (functionp spec-value))
				   (setq success? (funcall spec-value x-value)))
				  (t 
				   (setq success? (equal x-value spec-value))))
				 (setq i (+ i 1))))
			 success?))
		  ((and (ht-p x) (ht-p spec))
		   (let* ((success? t)
				  (i 0)
				  (x-ks (keys% x))
				  (spec-ks (keys% spec))
				  (x-len (length x-ks))
				  (spec-len (length spec-ks))
				  (limit (min x-len spec-len)))
			 (while (and success? (< i limit))
			   (let* ((x-value (get% x (nth i x-ks)))
					  (spec-value (get% spec (nth i spec-ks))))
				 (cond
				  ((and (container? x-value)
						(container? spec-value))
				   (setq success? (MATCH-TABLE x-value spec-value)))
				  ((and (functionp spec-value))
				   (setq success? (funcall spec-value x-value)))
				  (t 
				   (setq success? (equal x-value spec-value))))
				 (setq i (+ i 1))))
			 success?)))))
	(MATCH-TABLE X SPEC)))

(defalias '%. '%get)
(defalias '%! '%set)

(cl-defun menu@ (prompt lst &key action (depth 1))
  (cl-labels ((-menu (prompt lst action depth current-depth)
				(let* ((lst (if (alistp lst)
								(cl-loop for x in lst
										 collect (propertize (format "%s" (car x)) 'value (last@ x)))
							  (cl-loop for i in (range@ 0 (length (list 1 2 3)) 2)
									   collect (propertize (format "%s" (nth lst i)) 'value (nth lst (1+ i))))))
					   (selection (if (not action)
									  (ivy-read prompt lst)
									(ivy-read prompt lst :action action)))
					   (value (get-text-property 0 'value selection)))
				  (if (and (< current-depth depth)
						   (or (alistp value)
							   (and  
								(listp value)
								(stringp (car value))
								(= 0 (% (length value) 2)))))
					  (-menu selection value action depth (1+ current-depth))
					value))))
	(let* ((action (if (closurep action)
					   `(lambda ,@(nthcdr 2 action))
					 action))
		   (action (if (functionp action) (eval action) action))
		   (-action (if (and (listp action)
							 (or (listp (car action))
								 (integerp (car action))))
						(progn
						  (cl-loop for x in action
								 collect (if (not (listp x))
											 x
										   (let* ((fn (nth 1 x))
												  (fn `(lambda (selection)
														 (funcall ,fn (get-text-property 0 'value selection))))
												  (fn (eval fn))
												  (form (list (nth 0 x) fn (nth 2 x))))
											 form))))
					  (eval
					   `(lambda (selection)
						  (funcall ,action (get-text-property 0 'value selection)))))))
	  (-menu prompt lst -action depth 1))))

;; (menu@ "% " '(("a" (1 2 3 4)) ("b" 2))
;; 	   :action '(1 ("o" (lambda (value) (message "%s" value)) "test-action-1")))
