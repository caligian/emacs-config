(defun container? (x)
  (or (ht-p x)
      (eieio-object-p x)
      (alistp x)
      (listp x)))

(defalias 'containerp 'container?)

(defun %get (X &rest KS)
  (cl-labels ((list-get (x k)
		(when-let* ((ok? (numberp k))
			    (len (length x))
			    (k (if (< k 0) (+ len k) k))
			    (k (when (< k len) k)))
		  (nth k x)))
	      (alist-get (x k)
		(when-let* ((v (assoc k x))
			    (v (cdr v)))
		  (if (= 1 (length v))
		      (nth 0 v)
		    v)))
	      (hash-table-get (x k)
		(get% x k))
	      (object-get (x k)
		(slot-value x k))
	      (get (x k)
		(cond
		 ((alistp x)
		  (alist-get x k))
		 ((listp x)
		  (list-get x k))
		 ((ht-p x)
		  (ht-get x k))
		 ((eieio-object-p x)
		  (slot-value x k))))
	      (rget (x ks)
		(let* ((k (car ks))
		       (next (cdr ks))
		       (v (get x k)))
		  (if (not next)
		      v
		    (when (container? v)
		      (rget v next))))))
    (rget X KS)))

(defun %rm (X &rest ks)
  (cl-labels ((list-rm (x k)
		(when-let* ((ok? (numberp k))
			    (len (length x))
			    (k (if (< k 0) (+ len k) k))
			    (k (when (< k len) k))
			    (v (nth k x)))
		(if (equal k 0)
		    (progn
		      (setcar x (car (cdr x)))
		      (setcdr x (cdr (cdr x)))
		      v)
		  (progn
		    (setcdr (nthcdr (1- k) x) (nthcdr (1+ k) x))
		    v))))
	      (hash-table-rm (x k)
		(let* ((v (ht-get x k)))
		  (ht-remove x k)
		  v))
	      (alist-rm (x k)
		(when-let* ((v (assoc k x)))
		  (assq-delete-all k x)
		  v))
	      (object-rm (x k)
		(let* ((v (slot-value x k)))
		  (slot-unbound x k)
		  v))
	      (RM (x k)
		(cond
		 ((alistp x)
		  (alist-rm x k))
		 ((listp x)
		  (list-rm x k))
		 ((ht-p x)
		  (hash-table-rm x k))
		 ((eieio-object-p x)
		  (object-rm x k)))))
    (if (singleton? ks)
	(RM X (last@ ks))
      (let* ((found (apply #'%get X ks))
	     (level (apply #'%get X (butlast ks))))
	(RM level (last@ ks))
	found))))

(defun %set (X &rest ks-and-value)
  (cl-labels ((list-set (x k value)
		(when-let* ((ok? (numberp k))
			    (len (length x))
			    (k (if (< k 1) (+ len x) k))
			    (k (when (k < len) k)))
		  (setf (nth k x) value)
		  x))
	      (hash-table-set (x k value)
		(ht-set x k value)
		x)
	      (alist-set (x k value)
		(when-let* ((v (assoc k x)))
		  (setf (cdr v) value)
		  v))
	      (object-set (x k value)
		(setf (slot-value x k) value)
		x)
	      (SET (x k value)
		(cond
		 ((alistp x)
		  (alist-set x k value))
		 ((listp x)
		  (list-set x k value))
		 ((ht-p x)
		  (hash-table-set x k value))
		 ((eieio-object-p x)
		  (object-set x k value))))
	      (RSET (x ks value)
		(if (singleton? ks)
		    (SET x (car ks) value)
		  (when-let* ((found (apply #'%get x (butlast ks))))
		    (when (container? found)
		      (SET found (last@ ks) value))))))
    (RSET X (butlast ks-and-value) (last@ ks-and-value))))

(defun %update (x &rest ks-and-fn)
  (when-let* ((fn (last@ ks-and-fn))
	      (ks (butlast ks-and-fn))
	      (v (apply '%get x ks))
	      (v (funcall fn v)))
    (apply '%set x (append@ ks v))))

(defun %select (x &rest ks)
  (cl-loop for k in ks
	   collect (apply '%get x (->list k))))

(defun %rmq (x &rest ks)
  (cl-loop for k in ks
	   collect (apply '%rm x (->list k))))

(defun %setq (x &rest form)
  (cl-loop for i from 0 below (length form)
	   when (= 0 (% i 2))
	   do (let* ((k (->list (nth i form)))
		     (v (nth (+ i 1) form)))
		(apply #'%set x (append@ k v))))
  x)

(defun %compare (X SPEC)
  (cl-labels
      ((MATCH-TABLE (x spec)
	 (cond
	  ((functionp spec)
	   (and (funcall spec x) x))
	  ((and (listp x) (listp spec))
	   (let* ((success? t)
		  (i 0)
		  (x-len (length x))
		  (spec-len (length spec))
		  (limit (min x-len spec-len)))
	     (while (and success? (< i limit))
	       (let* ((x-value (nth i x))
		      (spec-value (nth i spec)))
		 (cond
		  ((and (container? x-value)
			(container? spec-value))
		   (setq success? (MATCH-TABLE x-value spec-value)))
		  ((and (functionp spec-value))
		   (setq success? (funcall spec-value x-value)))
		  (t 
		   (setq success? (equal x-value spec-value))))
		 (setq i (+ i 1))))
	     success?))
	  ((and (ht-p x) (ht-p spec))
	   (let* ((success? t)
		  (i 0)
		  (x-ks (keys% x))
		  (spec-ks (keys% spec))
		  (x-len (length x-ks))
		  (spec-len (length spec-ks))
		  (limit (min x-len spec-len)))
	     (while (and success? (< i limit))
	       (let* ((x-value (get% x (nth i x-ks)))
		      (spec-value (get% spec (nth i spec-ks))))
		 (cond
		  ((and (container? x-value)
			(container? spec-value))
		   (setq success? (MATCH-TABLE x-value spec-value)))
		  ((and (functionp spec-value))
		   (setq success? (funcall spec-value x-value)))
		  (t 
		   (setq success? (equal x-value spec-value))))
		 (setq i (+ i 1))))
	     success?)))))
    (MATCH-TABLE X SPEC)))

(defalias '%. '%get)
(defalias '%! '%set)
